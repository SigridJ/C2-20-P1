\chapter{Algoritmer}
Dette kapitel tager udgangspunkt i \citep{dmat}, medmindre andet er angivet.\\ 
\\
Mange matematiske problemer kan ikke løses ved hjælp af en simpel beregning, men kræver i stedet en række af skridt, der giver en løsning til problemet. 
En beskrivelse af den nødvendige sekvens af skridt kaldes en algoritme. 


\begin{defn}
En algoritme er et endeligt sæt af præcise instruktioner, som beskriver udførelsen af en beregning eller løsning af et problem.
\end{defn}

I denne rapport vil der blive brugt pseudokode til at beskrive, hvordan man kan opstille en algoritme i computersprog. 
En pseudokode kan ikke skrives direkte ind i et programmeringsprogram men kan let oversættes til et ønsket programmeringssprog og kan let læses og forståes. 
I dette kapitel vil tre algoritmer blive beskrevet, for at give en ide om, hvad en algoritme kan bruges til. 

\section{Eksempler på algoritmer}
\subsection{Søgealgoritme}
Skal den største værdi i en liste findes, kan dette gøres nemt ved hjælp af en algoritme. 
Selvom det kan virke meget simpelt at læse en liste igennem og finde det største tal, kan det blive problematisk og tidskrævende, hvis der er tale om en længere liste. 
Derfor kan en algoritme være smart, da nogle algoritmer hurtigt kan gennemgå lange lister. 
Desuden kan en algoritme løses af en computer, hvilket også gør det nemmere. 
En sådan algoritme kan udføres ved at sætte det første element lig med en variabel $maks$. 
Dernæst sammenlignes denne værdi med det næste element, som  $maks$ overtager, hvis det er større end den nuværende værdi af $maks$. 
Er det næste element mindre end det nuværende $maks$, sker der ikke noget, og der fortsættes til det næste element på listen. 
Dette gentages indtil hele listen er gennemgået, hvorefter maks returneres.
Herunder ses et eksempel på hvordan en sådan søgealgortime kan skrives med pseudokode:


\begin{algorithm}
\caption{Find maksimalt element i en liste}
\label{find_maks}
\textbf{procedure} $ maks(a_1, a_2, ... a_n) $

$ maks:=a_1 $ \\
\textbf{for} $i :=2$ \textbf{til} $n$ \\
$\-$ $\-$ $\-$ $\-$ $\-$ $\-$
\textbf{hvis} $maks<a_i$ \textbf{så}
$maks:=a_i$ \\
\textbf{returner} $maks \lbrace maks$ er det største element $\rbrace$
\end{algorithm}

\subsection{Bubblesort}

Et andet problem, der kan løses ved hjælp af algoritmer, er sorteringen af elementerne i en liste. 
Til dette findes der flere forskellige algoritmer, men her vil kun "Bubblesort$"$ blive beskrevet. 
I Bubblesort algoritmen undersøges ét element i listen af gangen. 
Elementet sammenlignes med det efterfølgende element således, at det bytter plads med det næste element, hvis dette er af en lavere værdi. 
Hvis elementet bytter plads med det næste element fortsættes sammenligningen med det efterfølgende element. 
Hvis ikke de to bytter plads, sammenlignes det næste element med det, der kommer efter det. 
Når hele listen er gennemgået gentages proceduren, men denne gang sammenlignes der ikke med det sidste element i listen, da det allerede vil være det største element. 
Dette gentages $n-1$ gange, da det sidste skridt får de to første elementer på plads. 
Med Pseudokode kan algoritmen skrives sådan:

\begin{algorithm}
\caption{Bubblesort}
\label{bubblesort}
\textbf{procedure} $Bubblesort(a_1, a_2, ..., a_n   : $ reelle tal og hvor $n \geq 2)$ \\
\textbf{for} $i:=1$ \textbf{til} $n-1$ \\
$\-$ $\-$ $\-$ $\-$ $\-$ $\-$
\textbf{for} $j:=1$ \textbf{til} $n-i$ \\
$\-$ $\-$ $\-$ $\-$ $\-$ $\-$
$\-$ $\-$ $\-$ $\-$ $\-$ $\-$
\textbf{hvis} $a_j>a_{j+1}$ \textbf{så} byt $a_j$ og $a_{j+1}$ \\
$\lbrace a_1, a_2, ..., a_n $ står nu i voksende rækkefølge $\rbrace $
\end{algorithm}

\subsection{Grådige algoritmer}
De sidste algoritmer, der vil blive beskrevet i kapitlet er grådige algoritmer, som bruges til at optimere. 
Grådige algoritmer kan se ud på mange måder, alt efter hvad det er som skal optimeres. 
Ideen med en grådig algoritme er, at den er designet til i hvert trin, at tage den bedste beslutning. 
Algoritmen kan eventuelt bruges til finde fordelingen af mønter, hvis et bestemt beløb skal opnåes. 
Ønskes det at finde det mindste antal mønter til at dække et bestemt beløb, sættes møntværdierne ind i en liste sorteret fra største til mindste mønt. 
Den første mønt sammenlignes med det samlede beløb. 
Er mønten mindre end det samlede beløb, tilføjes 1 til den variabel, der beskriver det samlede antal mønter. 
Værdien af mønten trækkes fra beløbet, så kun det resterende beløb er tilbage. 
Er mønten større fortsættes til næste mønt.  
Det første skridt gentages indtil mønten er større end det resterende beløb, da det er muligt at have flere af den samme mønt. 
Når det resterende beløb er 0, behøves der ikke flere mønter og antallet af mønter returneres.

\begin{algorithm}
\caption{algoritme for antal mønter}
\label{greedy_algorithm}
\textbf{procedure} $mønter(m_1, m_2, ..., m_r: $ hele, positive værdier af de mønter man regner med, \\ 
hvor $m_1>m_2>...>m_r;$  $n$: det ønskede hele, positive beløb) \\
\textbf{for} $i:=1$ \textbf{til} $r$ \\
$\-$ $\-$ $\-$ $\-$ $\-$ $\-$
$d_i:=0$ $\lbrace d_i$ tæller antallet af brugte mønter $\rbrace$ \\
$\-$ $\-$ $\-$ $\-$ $\-$ $\-$
\textbf{når} $n \geq m_i$ \\
$\-$ $\-$ $\-$ $\-$ $\-$ $\-$
$\-$ $\-$ $\-$ $\-$ $\-$ $\-$
$d_i:=d_i+1$ $\lbrace$ tilføjer en mønt $\rbrace$ \\
$\-$ $\-$ $\-$ $\-$ $\-$ $\-$
$\-$ $\-$ $\-$ $\-$ $\-$ $\-$
$n:=n-m_i$ \\
$\lbrace d_i$ er det antal af mønter der skal bruges for at opfylde beløbet $n\rbrace$
\end{algorithm}
 

\begin{thm}
\label{19_kr}
Hvis $n$ er et positivt heltal, så vil det optimale antal af mønter for at opfylde $n$, hvor man bruger 20-kroner, 10-kroner, 5-kroner, 2-kroner og 1-kroner, være en 10-krone, en 5-krone, to 2-kroner og en 1-krone, hvor der ikke samtidigt kan være både to 2-kroner og en 1-krone.
Beløbet i 10-kroner, 5-kroner, 2-kroner og 1-kroner kan ikke overstige 19 kroner.  
\end{thm}

\begin{proof}
\label{19_kr_bevis}
Dette bevis er et modstidsbevis. 
Hvis antallet af en mønt er større end angivet, kan de erstattes af færrer mønter som opfylder den samme værdi. 
Hvis der eksempelvis er 2 10-kroner kan de erstattes af en 20-krone. 
Hvis der er 2 5-kroner kan de erstattes af 1 10-krone. 
Er der 3 2-kroner kan de erstattes af 1 5-krone og 1 1-krone. 
På samme måde hvis der er 2 1-kroner kan de erstattes af 1 2-krone. 
Fordi der maksimae antal mønter er en 10-krone, en 5-krone, to 2-kroner og en en 1-krone, men der ikke kan være to 2-kroner og en 1-krone på samme tid, bliver det maksimale beløb der kan opfyldes med mønterne 19 kroner. 
\end{proof}

\begin{thm}
\label{gradig_satning}
Den gådige algoritme for danske mønter finder det optimale antal mønter til at opfylde et beløb.
\end{thm}

\begin{proof}
\label{gradig_bevis}
Dette bevis er et modstridsbevis. 
Gå ud fra, at der er et beløb $n$, som kan opfyldes ved hjælp af 1-kroner, 2-kroner, 5-kroner, 10-kroner og 20-kroner, ved at bruge færre mønter end den grådige algoritme. 
Det bemærkes, at $t'$, det optimale antal af 20-kroner der bruges for at opfylde $n$, må være det samme som $t$, antallet af 20-kroner den grådige algoritme vil bruge. 
Dette vides, fordi det ses ud fra sætning \ref{19_kr}, da der med mønter under 20-kroner maks vil kunne findes 19 kroner. 
Det betyder, at $t'$ og $t$ bliver nødt til at være det samme, da $t'$ ellers vil bruge mere end det optimale antal mønter. 
Der er altså det samme antal 20-kroner i begge tilfælde, det samme gælder for de resterende mønter. 
Den grådige algoritme vil bruge flest mulige 10-kroner, hvilket vil være det samme antal som det optimale, da det optimale antal er 1. 
Det samme gælder for 5-kroner, 2-kroner og 1-kroner. 
Det kan dermed konkluderes, at den grådige algoritme vil finde det optimale antal mønter.

\end{proof}

\noindent For det møntsystem, der er i Danmark, fungerer Algoritme \ref{greedy_algorithm} godt. 
Forestiller man sig et andet møntsystem, der eksempelvis indeholder mønter af værdierne 20, 15 og 5, vil algoritmen ikke finde det optimale antal. 
Køres møntsystemet igennem Algoritme\ref{greedy_algorithm}, hvor det ønskede beløb er 30, vil algoritmen returnere, at der skal bruges tre mønter. 
Den vil nemlig starte med at tilføje en mønt af værdien 20 og derefter to af værdien 5.
Det optimale antal møter i dette tilfælde er dog to, idet to mønter af værdien 15 ville have opfyldt beløbet.
%\input{incl/main/halting_problem}